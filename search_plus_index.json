{"./":{"url":"./","title":"Introduction","keywords":"","body":"短链接系统 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"产品构思.html":{"url":"产品构思.html","title":"产品构思","keywords":"","body":"产品构思 短链接服务已经有很多了，很多时候如果需要用到短链接都是使用第三方的服务，如果有一天不允许用第三方服务呢？ 对于短链接而言，特点可能就是短了，同类竞品中还同时提供许多其他的服务，例如，数据分析等等。 在有诸多竞品的情况下，为什么还需要自建呢？ 如果连这个这个都弄不明白，那么这个产品注定是失败的。 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"同类竞品.html":{"url":"同类竞品.html","title":"同类竞品","keywords":"","body":"同类竞品 百度短网址 百度短网址 可能是国内主动用户最多的了吧。 它提供了网址的缩短、还原、删除、数据报表这些功能，提供 API 接口，删除功能只在 API 中提供，网页上没有。 网址的有效期只有一年或长期这两种，且 API 没有提供修改功能。 新浪短链接 新浪短链接 t.cn 可能在国内是被动用户最多的了，目前不提供 API 接口，但有第三方 API 可用。 腾讯短链接 腾讯短链接 url.cn 最开始是为了对抗新浪短链接推出的网址压缩服务，后来腾讯微博倒闭，虽然没有停止解析，但也没有对外开放接口。 和新浪一样不提供 API 接口，但有第三方 API 可用。 Twitter 短链接 既然提起了新浪、腾讯的短链接服务，就不得不提一提 Twitter 短链接 t.co 了，毕竟都是模仿嘛。 因为它们抄的都是 Twitter 短链接，所以一样的，不提供 API 接口，有第三方工具可用。 这是为什么呢？短连接服务最开始只是因为推文不能超过 140 字的限制，而一个网址可能是很长的， 这个服务是用于供缩短发布到 Twitter 的链接，所有发布在 Twitter 的链接都会用它来缩短，第三方 API 的原理大多如此。 Firebase 动态链接 Firebase 动态链接 的前身是 Google 短链接。 这里就不讨论它的前身了，因为它的确比它的前身更强大。只是，如名一般，动态链接不是短链接。 但是你可以绑定自己的域名，来让它变短。 它最大的特点就是支持 Android 和 iOS 的深层链接，所以它已经不单单是短网址了，动态链接更为合适。 同时还支持广告跟踪、社交元标记。 同时，它对于基本的短网址服务支持也很强，例如自定义索引（单个自定义、长度自定义等）。 对于其他竞品中的数据分析，它直接集成了 Google Analytics。 而且它的数据分析是可以通过 API 调用的。 它够专业，专业到如果你想提供给普通用户，你得自己写一个前端，将部分功能提供给用户。至于后端，它全包了。 U.NU 短链接 U.NU 短链接 真的就是短，这是一个真正的短链接服务了。 但是它是个人运营的，第一次看到它的时候，它还是直接重定向跳转的，现在变成了需要点击才能跳转，可能只在付费服务里提供了吧。 它真的就只是短链接服务了，目前能看到的，就只有创建短链接和简单的访问统计，没有其他的功能了。 其他短链接服务 mrw 51la 不是我说，上个 HTTPS 很难？ 0x3 51la 这些短网址服务大多都提供数据分析功能，并以此为卖点。 总结 名称 域名 长度 映射关系 新浪 t.cn 8 一对一 百度 dwz.cn 7 一对一 腾讯 url.cn 7 一对一 Twitter t.co 10 一对一 Firebase 自定义 自定义 一对多 U.NU u.nu 自定义 一对一 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"需求分析.html":{"url":"需求分析.html","title":"需求分析","keywords":"","body":"需求分析 看了看竞品，如果自己要做一个短网址服务应该针对什么方向、做什么用途呢？ 讲真，我想要的 Firebase 动态链接都有，如果只是简简单单做一个短网址服务就和 U.NU 一样了。 为什么要自建？因为可扩展性强、自主性更高。 可扩展性强、自主性高，这个需求基本上就是对应的企业级服务了。 一个企业级服务，使用量肯定不低，需要考虑上分布式，单实例可以直接放弃了。 数据分析肯定得有，不然短链接服务的意义就不大了，不如直接用第三方的。 链接映射应该一对一还是一对多？ 一般而言，一个长网址，在不同的地点、用户等情况下生成的短网址应该不一样，这样在后端可以更好的进行数据分析。 如果一个长网址与一个短网址对应，那么数据分析可能就不是那么的好做了。 但是不同用户提交相同输入，不需要重复生成新的短链 ID ，只是需要业务进行处理和保证。 对于短链接的长度也不得考虑，上表中竞品的长度还是很值得考量的。 除开可以自定义的，最短都是 7 位，最长的是 Twitter 的 10 位。 在短链接上需要考虑 URL 字符的问题，一般都是使用大小写字母、数字，也就是 base62 了。 其他的可能就是自定义后缀，这些了。 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"技术方案.html":{"url":"技术方案.html","title":"技术方案","keywords":"","body":"技术方案 使用 base62 作为短链接字符编码，也就是 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 基础位数设为 7 位，1 - 6 位作为自定义后缀的需求使用，可自动扩容为更高位 ID 允许更新链接地址、设置有效期，不过考虑到数据库冗余，设置有效期放到扩展服务以定时删除的功能项出现 为了满足数据分析的需求，使用一对多的关系 考虑到分布式的需求，使用发号器来解决号段分发问题 使用 Redis 集群作为后端数据库，MariaDB 作为数据备份 使用基于 TCP 协议的 RPC 调用 使用 JSON 作为数据交换格式，Protobuf 在数据很小的项目中压缩效果不明显，且吃 CPU powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"detail/1.数据库.html":{"url":"detail/1.数据库.html","title":"数据库","keywords":"","body":"数据库 对于功能的复杂软件，设计数据库必然较为麻烦。 先分析一下软件的功能，看看会有什么数据表。 不说别的，先设计一个通用模板。 通用模板 import \"time\" type Model struct { ID uint64 `sql:\"auto_increment;primary_key;unique\" json:\"id\" structs:\"id\"` CreatedAt time.Time `structs:\"createdAt\"` UpdatedAt time.Time `structs:\"updatedAt\"` DeletedAt *time.Time `sql:\"index\" structs:\"deletedAt\"` } 用户 在通用模板的基本上，结合业务逻辑，得先有用户，而且 API 的调用怎么说也得设置一个 Token 不是。 type User struct { Model Username string Password string Token string } 数据 短链接系统，必然需要存储链接。 type Data struct { Model URL string `gorm:\"size:200\" json:\"url\"` // 其实链接长度上限设置位多少还没去做评估，毕竟数据量大了之后不得不考虑 UserID uint64 // 外键 用户ID } 访问记录 有了储存链接信息的地方，那么链接必然会有点击信息，用来做数据分析。 import \"net\" type AccessRecord struct { Model URL uint64 // 外键 data.id UserAgent string Referrer string IPAddr net.IP CountryCode string } 用户表添加数据记录 其实对于业务需求而言，每一次查看用户创建的短链接时，查询量都非常庞大。 是不是需要在用户表上记录一下用户拥有的短链接呢？ type AccessRecord struct { Model Username string Password string Token string Bind string // 用数组来记录 [0, 2, 5, 6] } 数据库扩展 有了这些数据表，基本功能就可以在上面实现了。 但是这里关于数据库的水平扩展还是需要提一下。 对于储存短链接的数据表，里面存有短链接的 ID、对应的 URL 和所有者 ID。 那么水平扩展该怎么做呢？自然是分片数据存储。 例如： 10 进制 62 进制 1,000,000 0004c92 2,000,001 0008oi5 这里用到的 62 进制是 数字 + 小写字母 + 大写字母，实际使用中，不一定会是这样的组合 假设分片策略是每张表储存一百万条数据。 用户查询 0004c92 对应的 URL，系统将其转换为十进制 1000000 查询分片表，找到了 1000000 对应的数据表名位 1 在表 1 内查找 ID 为 1000000 的数据 用户查询 0008oi5 对应的 URL，系统将其转换为十进制 2000001 查询分片表，找到了 2000001 对应的数据表名位 3 在表 3 内查找 ID 为 1 的数据 分片策略可以自由调整，比如说某台机器性能是其他机器的两倍，那么就可以在分片策略内调整它的数据范围 分片策略可以放在数据库里，然后主动下发更新策略，也可以由 k8s 完成。 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"detail/2.短链接.html":{"url":"detail/2.短链接.html","title":"短链接","keywords":"","body":"短链接 其实在设计数据库的时候就已经涉及到了短链接的部分内容。 数据表里面，我们是不直接存储 base62 字符的，是通过将 62 进制转换为 10 进制存储的。 对于数据库而言，使用数字主键占据的储存空间是比字符小的，而且性能比字符主键好。 但是在一般情况下，使用字符主键适合大量数据的插入、更新，尤其是高并发、分布式环境下。 但在上文已经说了关于扩展方面的问题，这里无需考虑这个问题。 本节其实没什么内容可讲的，因为就只是一个简单的 62 进制与 10 进制的相互转换。 package main import ( \"fmt\" \"math\" \"strconv\" \"strings\" ) var data map[int]string = map[int]string{ 0: \"0\", 1: \"1\", 2: \"2\", 3: \"3\", 4: \"4\", 5: \"5\", 6: \"6\", 7: \"7\", 8: \"8\", 9: \"9\", 10: \"a\", 11: \"b\", 12: \"c\", 13: \"d\", 14: \"e\", 15: \"f\", 16: \"g\", 17: \"h\", 18: \"i\", 19: \"j\", 20: \"k\", 21: \"l\", 22: \"m\", 23: \"n\", 24: \"o\", 25: \"p\", 26: \"q\", 27: \"r\", 28: \"s\", 29: \"t\", 30: \"u\", 31: \"v\", 32: \"w\", 33: \"x\", 34: \"y\", 35: \"z\", 36: \"A\", 37: \"B\", 38: \"C\", 39: \"D\", 40: \"E\", 41: \"F\", 42: \"G\", 43: \"H\", 44: \"I\", 45: \"J\", 46: \"K\", 47: \"L\", 48: \"M\", 49: \"N\", 50: \"O\", 51: \"P\", 52: \"Q\", 53: \"R\", 54: \"S\", 55: \"T\", 56: \"U\", 57: \"V\", 58: \"W\", 59: \"X\", 60: \"Y\", 61: \"Z\", } func main() { fmt.Println(decimalToString(100000)) fmt.Println(stringToDecimal(\"q0U\")) } func decimalToString(num int) string { var i int var str, nstr string for num != 0 { i = num % 62 if 76 > i && i > 9 { str = data[i] } else { str = strconv.Itoa(i) } nstr = str + nstr num = num / 62 } return nstr } func stringToDecimal(num string) int { i := 0.0 nNum := len(strings.Split(num, \"\")) - 1 for _, value := range strings.Split(num, \"\") { tmp := float64(findKey(value)) if tmp != -1 { i = i + tmp*math.Pow(float64(62), float64(nNum)) nNum = nNum - 1 } else { break } } return int(i) } func findKey(in string) int { result := -1 for k, v := range data { if in == v { result = k } } return result } 这个函数是不能直接使用的，只是演示罢了。 项目中需要用到的函数是会前置加零的，这样来维持基础位数为 7 位 q0U 和 0000q0U 对应的短链接是不同的 为了不必要的误会，62 进制的 Map 映射表应该打乱顺序 发号器不一定要按照顺序发放号段 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"detail/3.发号器.html":{"url":"detail/3.发号器.html","title":"发号器","keywords":"","body":"发号器 发号器的机制也需要讲一讲。 一般情况下，在系统启动之后，发号器应当加载已用号段。 单生成器发请求过来之后，发号器会根据规则生成一个号段然后返回。 这个规则可能包含生成那张表内的号段、有多少个号码。 发号器的日志是必不可少的，如果出现了不可预估的错误，没日志可真不好查。 发号器的机制其实很简单的，实现起来也很简单。 func load() { // 加载已用号段 // 加载规则 } func Listen() { // 等待请求，返回生成的数据 rerutn generate() } func generate() { // 根据规则生成号段 } 还有一点需要提一下，加载已用号段是需要检查数据库的，因为号段并不是放下去之后就一定会被用完的。 比如，某个生成器的主机断电了，那么就肯定会有很多号码没使用。 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"detail/4.生成器.html":{"url":"detail/4.生成器.html","title":"生成器","keywords":"","body":"生成器 其实生成器也挺简单的，一是因为系统并不复杂，二是因为已经都拆解开来了。 生成器获取请求之后，第一步会做什么？ 检查输入，根据 Token 规则、URL 规则进行校验，防止非法请求 查询缓存服务器校验 Token 查询号段池，随便挑一个或者按照规则挑一个号码 向缓存服务器提交数据，如果功能就返回号段数据了 这些都是正常步骤，其实生成器内还有一个协程，它负责维护号段池 生成器启动，向发号器申请号段 获取到号段之后存入号段池 每次号段池内被取走一个号码时，计算号段池内剩余号码 如果号码少于一定数量，再向发号器申请号段并存入 号段池不应该像数组或者字典一样储存，应该只使用一个变量来储存。 增加号段、取走号段时，应当加锁。 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"detail/5.访问器.html":{"url":"detail/5.访问器.html","title":"访问器","keywords":"","body":"访问器 访问器负责访问，同时需要写入访问记录。 访问器被请求时，应该先做什么？ 检查输入，根据规则校验 URL，防止非法请求 黑名单机制，如果有要屏蔽的 UserAgent 就屏蔽 查询缓存服务器，查找对应的网址 返回数据。同时向缓存服务器内添加访问记录 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"detail/6.缓存.html":{"url":"detail/6.缓存.html","title":"缓存","keywords":"","body":"缓存 缓存的机制是这个系统中最复杂的了。 冷启动，缓存需要从备份中加载数据，也就是从 MariaDB 中加载数据。 数据并不是都加载到一个里面。 比如，根据用户的数据并不需要全部加载。 用户数据可以只加载 Token 的，如果集成了更复杂的功能，比如限制数量什么的，就再加载其他的。 Token 基本上是只读的。 关于短链接，应该按照数据库设计中说的一样，加载到不同的数据库中，且那些数据库可以设置主从热备。 对于访问记录的存储，Redis 应当定时批量写入 MariaDB，然后清理掉，这种只写一次、不常读的数据存着也没用。 所有数据，都应当定时写入 MariaDB，以达到备份的作用 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"detail/7.备份.html":{"url":"detail/7.备份.html","title":"备份","keywords":"","body":"备份 MariaDB 说着是备份，其实也不然，关于用户管理等依旧是直接接入数据库的。 当然，也可以接入缓存，钱多的烧的话。 MariaDB 除开用户管理，还需要进行数据分析，这个任务应当定时执行，例如每天凌晨执行，将统计结果写入数据库。 如果有实时查看的需求，对数据库压力可能会比较大，建议上缓存。 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"可行性分析.html":{"url":"可行性分析.html","title":"可行性分析","keywords":"","body":"可行性分析 powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "},"附录.html":{"url":"附录.html","title":"附录","keywords":"","body":"附录 流程图源码 在线编辑器 graph TD A[用户] -->|访问| B{{负载均衡}} B --> c1 B --> d3 B --> E{扩展服务} subgraph \"生成器 集群\" c1[Node 1] c2[Node 2] c3[Node 3] c4[Node...] end subgraph \"访问器 集群\" d1[Node 1] d2[Node 2] d3[Node 3] d4[Node...] end subgraph \"缓存 集群\" r1[Master] r2[Slave 1] r3[Slave 2] r4[Slave ...] end c2 ---|索取号段| F[发号器] c1 -->|写入号码| r1 d1 -->|查询缓存| r2 E --> Z{数据分析} F -->|写入| r1 r4 -->|更新同步| X[(数据库)] Z{数据分析} --> X[(数据库)] powered by Gitbook该文件修订时间： 2020-03-25 07:27:25 "}}